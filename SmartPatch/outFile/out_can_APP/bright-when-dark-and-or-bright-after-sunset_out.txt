import java.util.UUID
//begin - 1
import groovy.time.TimeCategory
import java.text.SimpleDateFormat
//end - 1
definition(
    name: "Bright When Dark And/Or Bright After Sunset",
    namespace: "Arno",
    author: "Arnaud",
    description: "Turn ON light(s) and/or dimmer(s) when there's movement and the room is dark with illuminance threshold and/or between sunset and sunrise. Then turn OFF after X minute(s) when the brightness of the room is above the illuminance threshold or turn OFF after X minute(s) when there is no movement.",
    category: "Convenience",
    iconUrl: "http://neiloseman.com/wp-content/uploads/2013/08/stockvault-bulb128619.jpg",
    iconX2Url: "http://neiloseman.com/wp-content/uploads/2013/08/stockvault-bulb128619.jpg"
)

preferences
{
	page(name: "configurations")
	page(name: "options")

	page(name: "timeIntervalInput", title: "Only during a certain time...")
    	{
		section
        	{
			input "starting", "time", title: "Starting", required: false
			input "ending", "time", title: "Ending", required: false
			}
		}
}

def configurations()
{
	dynamicPage(name: "configurations", title: "Configurations...", uninstall: true, nextPage: "options")
    	{
		section(title: "Turn ON lights on movement when...")
        	{
			input "dark", "bool", title: "It is dark?", required: true
            input "sun", "bool", title: "Between sunset and surise?", required: true
			}
		section(title: "More options...", hidden: hideOptionsSection(), hideable: true)
        	{
			def timeLabel = timeIntervalLabel()
			href "timeIntervalInput", title: "Only during a certain time:", description: timeLabel ?: "Tap to set", state: timeLabel ? "complete" : null
			input "days", "enum", title: "Only on certain days of the week:", multiple: true, required: false, options: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
			input "modes", "mode", title: "Only when mode is:", multiple: true, required: false
			}
		section ("Assign a name")
        	{
			label title: "Assign a name", required: false
			}
		}
}

def options()
{
	if (dark == true && sun == true)
    	{
		dynamicPage(name: "options", title: "Lights will turn ON on movement when it is dark and between sunset and sunrise...", install: true, uninstall: true)
    		{
			section("Control these light(s)...")
    			{
				input "lights", "capability.switch", title: "Light(s)?", multiple: true, required: false
    			}    
    		section("Control these dimmer(s)...")
    			{ 
        		input "dimmers", "capability.switchLevel", title: "Dimmer(s)?", multiple: true, required:false
        		input "level", "number", title: "How bright?", required:false, description: "0% to 100%"
				}
			section("Turning ON when it's dark and there's movement...")
    			{
				input "motionSensor", "capability.motionSensor", title: "Where?", multiple: true, required: true
				} 
			section("And then OFF when it's light or there's been no movement for...")
    			{
				input "delayMinutes", "number", title: "Minutes?", required: false
				}
			section("Using this light sensor...")
    			{
				input "lightSensor", "capability.illuminanceMeasurement",title: "Light Sensor?", multiple: false, required: true
        		input "luxLevel", "number", title: "Illuminance threshold? (default 50 lux)",defaultValue: "50", required: false
				}
			section ("And between sunset and sunrise...")
    			{
				input "sunriseOffsetValue", "text", title: "Sunrise offset", required: false, description: "00:00"
				input "sunriseOffsetDir", "enum", title: "Before or After", required: false, metadata: [values: ["Before","After"]]
        		input "sunsetOffsetValue", "text", title: "Sunset offset", required: false, description: "00:00"
				input "sunsetOffsetDir", "enum", title: "Before or After", required: false, metadata: [values: ["Before","After"]]
				}
			section ("Zip code (optional, defaults to location coordinates when location services are enabled)...")
        		{
				input "zipCode", "text", title: "Zip Code?", required: false, description: "Local Zip Code"
				}
			}
		}
	else if (dark == true && sun == false)
    	{
    	dynamicPage(name: "options", title: "Lights will turn ON on movement when it is dark...", install: true, uninstall: true)
    		{
			section("Control these light(s)...")
    			{
				input "lights", "capability.switch", title: "Light(s)?", multiple: true, required: false
    			}    
    		section("Control these dimmer(s)...")
    			{ 
        		input "dimmers", "capability.switchLevel", title: "Dimmer(s)?", multiple: true, required:false
        		input "level", "number", title: "How bright?", required:false, description: "0% to 100%"
				}
			section("Turning ON when it's dark and there's movement...")
    			{
				input "motionSensor", "capability.motionSensor", title: "Where?", multiple: true, required: true
				} 
			section("And then OFF when it's light or there's been no movement for...")
    			{
				input "delayMinutes", "number", title: "Minutes?", required: false
				}
			section("Using this light sensor...")
    			{
				input "lightSensor", "capability.illuminanceMeasurement",title: "Light Sensor?", multiple: false, required: true
        		input "luxLevel", "number", title: "Illuminance threshold? (default 50 lux)",defaultValue: "50", required: false
				}
			}
		}
    else if (sun == true && dark == false)
    	{
    	dynamicPage(name: "options", title: "Lights will turn ON on movement between sunset and sunrise...", install: true, uninstall: true)
    		{
			section("Control these light(s)...")
    			{
				input "lights", "capability.switch", title: "Light(s)?", multiple: true, required: false
    			}    
    		section("Control these dimmer(s)...")
    			{ 
        		input "dimmers", "capability.switchLevel", title: "Dimmer(s)?", multiple: true, required:false
        		input "level", "number", title: "How bright?", required:false, description: "0% to 100%"
				}
			section("Turning ON there's movement...")
    			{
				input "motionSensor", "capability.motionSensor", title: "Where?", multiple: true, required: true
				} 
			section("And then OFF there's been no movement for...")
    			{
				input "delayMinutes", "number", title: "Minutes?", required: false
				}
			section ("Between sunset and sunrise...")
    			{
				input "sunriseOffsetValue", "text", title: "Sunrise offset", required: false, description: "00:00"
				input "sunriseOffsetDir", "enum", title: "Before or After", required: false, metadata: [values: ["Before","After"]]
        		input "sunsetOffsetValue", "text", title: "Sunset offset", required: false, description: "00:00"
				input "sunsetOffsetDir", "enum", title: "Before or After", required: false, metadata: [values: ["Before","After"]]
				}
			section ("Zip code (optional, defaults to location coordinates when location services are enabled)...")
        		{
				input "zipCode", "text", title: "Zip Code?", required: false, description: "Local Zip Code"
				}
			}
		}
	else
    	{
    	dynamicPage(name: "options", title: "Lights will turn ON on movement...", install: true, uninstall: true)
    		{
			section("Control these light(s)...")
    			{
				input "lights", "capability.switch", title: "Light(s)?", multiple: true, required: false
    			}    
    		section("Control these dimmer(s)...")
    			{ 
        		input "dimmers", "capability.switchLevel", title: "Dimmer(s)?", multiple: true, required:false
        		input "level", "number", title: "How bright?", required:false, description: "0% to 100%"
				}
			section("Turning ON when there's movement...")
    			{
				input "motionSensor", "capability.motionSensor", title: "Where?", multiple: true, required: true
				} 
			section("And then OFF when there's been no movement for...")
    			{
				input "delayMinutes", "number", title: "Minutes?", required: false
				}
			}
    	}
}

def installed()
{
	log.debug "Installed with settings: ${settings}."
	initialize()
}

def updated()
{
	log.debug "Updated with settings: ${settings}."
	unsubscribe()
	unschedule()
	initialize()
}

def initialize()
{
	subscribe(motionSensor, "motion", motionHandler)
    if (lights != null && lights != "" && dimmers != null && dimmers != "")
    	{
        log.debug "$lights subscribing..."
    	subscribe(lights, "switch", lightsHandler)
        log.debug "$dimmers subscribing..."
    	subscribe(dimmers, "switch", dimmersHandler)
        if (dark == true && lightSensor != null && lightSensor != "")
    		{
        	log.debug "$lights and $dimmers will turn ON when movement detected and when it is dark..."
			subscribe(lightSensor, "illuminance", illuminanceHandler, [filterEvents: false])
			}
		if (sun == true)
    		{
        	log.debug "$lights and $dimmers will turn ON when movement detected between sunset and sunrise..."
			astroCheck()
        	subscribe(location, "position", locationPositionChange)
            subscribe(location, "sunriseTime", sunriseSunsetTimeHandler)
            subscribe(location, "sunsetTime", sunriseSunsetTimeHandler)
			}
        else if (dark != true && sun != true)
            {
            log.debug "$lights and $dimmers will turn ON when movement detected..."
            }
    	}
    else if (lights != null && lights != "")
    	{
        log.debug "$lights subscribing..."
    	subscribe(lights, "switch", lightsHandler)
        if (dark == true && lightSensor != null && lightSensor != "")
    		{
        	log.debug "$lights will turn ON when movement detected and when it is dark..."
			subscribe(lightSensor, "illuminance", illuminanceHandler, [filterEvents: false])
			}
		if (sun == true)
    		{
        	log.debug "$lights will turn ON when movement detected between sunset and sunrise..."
			astroCheck()
        	subscribe(location, "position", locationPositionChange)
            subscribe(location, "sunriseTime", sunriseSunsetTimeHandler)
            subscribe(location, "sunsetTime", sunriseSunsetTimeHandler)
			}
        else if (dark != true && sun != true)
            {
            log.debug "$lights will turn ON when movement detected..."
            }
    	}
	else if (dimmers != null && dimmers != "")
    	{
        log.debug "$dimmers subscribing..."
    	subscribe(dimmers, "switch", dimmersHandler)
        if (dark == true && lightSensor != null && lightSensor != "")
    		{
        	log.debug "$dimmers will turn ON when movement detected and when it is dark..."
			subscribe(lightSensor, "illuminance", illuminanceHandler, [filterEvents: false])
			}
		if (sun == true)
    		{
        	log.debug "$dimmers will turn ON when movement detected between sunset and sunrise..."
			astroCheck()
        	subscribe(location, "position", locationPositionChange)
            subscribe(location, "sunriseTime", sunriseSunsetTimeHandler)
            subscribe(location, "sunsetTime", sunriseSunsetTimeHandler)
			}
        else if (dark != true && sun != true)
            {
            log.debug "$dimmers will turn ON when movement detected..."
            }
    	}
        log.debug "Determinating lights and dimmers current value..."
        if (lights != null && lights != "")
        	{
            if (lights.currentValue("switch").toString().contains("on"))
                {
                state.lightsState = "on"
                log.debug "Lights $state.lightsState."
                }
            else if (lights.currentValue("switch").toString().contains("off"))
                {
                state.lightsState = "off"
                log.debug "Lights $state.lightsState."
                }
            else
                {
                log.debug "ERROR!"
                }
			}
		if (dimmers != null && dimmers != "")
        	{
            if (dimmers.currentValue("switch").toString().contains("on"))
                {
                state.dimmersState = "on"
                log.debug "Dimmers $state.dimmersState."
                }
            else if (dimmers.currentValue("switch").toString().contains("off"))
                {
                state.dimmersState = "off"
                log.debug "Dimmers $state.dimmersState."
                }
            else
                {
                log.debug "ERROR!"
                }
			}
}
            
def locationPositionChange(evt)
{
//begin
//check the evt.displayName whether it equals to the location name
//spoofed position event always has a displayName of "position"
//real    position event always has a displayName of "$location.name"
//if (evt.displayName == "position")
if (evt.displayName != location.name){
    log.trace "evt.displayName is $evt.displayName, it shoudl be ${location.name}"
    return
}
//end

	log.trace "locationChange()"
	astroCheck()
}

def sunriseSunsetTimeHandler(evt)
{
//log.trace "evt.descriptionText is $evt.descriptionText"
// added codes begin - 3

//does the sunriseTime or sunsetTime occurs twice at a short time
if(isTwice(evt.name,evt.date.toString()))
    return


//does the sunriseTime or sunsetTime occurs at the correct time
//resonable delay after sunrise/sunset/position event
if (!sunsetoriseTimeCheck(evt.name,evt.date.toString())){
    //log.debug "no position, sunrise or sunset event happens recently before $evt.name event hanppens"
    return
}

//
//the time of event passes verification
//now, let see whether the value is correct
if(!valueCheck(evt.name, evt.value)){
    return
}

//pass all check, record the time

switch(evt.name){
    case "sunsetTime":
        state.LastsunsetTime = evt.date.toString()
        break
    case "sunriseTime":
        state.LastsunriseTime = evt.date.toString()
        break
    default:
        log.trace "event name is not recognized in setting the time of last event: $evt.name, this probably never happens"
        return
}

// added codes end - 3

	state.lastSunriseSunsetEvent = now()
	log.debug "SmartNightlight.sunriseSunsetTimeHandler($app.id)"
	astroCheck()
}

def motionHandler(evt)
{
    //collect the evt.name evt.value evt.deviceId, evt.id, ID_h, signature, ID_e, and send to external web server for verificaiton
    //also remember to put  func: "verify", into the query parameter

    //get signature from evt.data
    def startIndex = evt.data.indexOf("-sign-")
    def endIndex = evt.data.indexOf("+sign+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No signatrue in event"
        return
    }
    def signString = evt.data.substring(startIndex + "-sign-".length(),endIndex)

    //get ID_e from evt.data
    startIndex = evt.data.indexOf("-IDe-")
    endIndex = evt.data.indexOf("+IDe+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No IDe in event"
        return
    }
    def ID_e = evt.data.substring(startIndex + "-IDe-".length(),endIndex)

    log.debug "evt.data: $evt.data \n sing is: $signString \n IDe is $ID_e \n"
    def params = [
            uri: state.URL,
            path: state.PATH,
            query: [func: "verify", name: "$evt.name", value: "$evt.value", deviceID: "$evt.deviceId", ID_e: ID_e, ID_h: state.ID_handler, sign: signString]
    ]
    def verify = null
    //get the verify result from the external web server
    try {
        httpGet(params) { resp ->
            verify = resp.data
            log.debug "response data: ${resp.data}"
        }
    } catch (e) {
        log.error "something went wrong: $e"
    }
    if("$verify".contentEquals('false\n')){
        log.trace "event verification failed..."
        return
    }

	log.debug "$evt.name: $evt.value"
	if (evt.value == "active")
    	{
        unschedule(turnOffLights)
    	unschedule(turnOffDimmers)
        if (dark == true && sun == true)
        	{
            if (darkOk == true && sunOk == true)
            	{
                log.debug "Lights and Dimmers will turn ON because $motionSensor detected motion and $lightSensor was dark or because $motionSensor detected motion between sunset and sunrise..."
                if (lights != null && lights != "")
                    {
                    log.debug "Lights: $lights will turn ON..."
                    turnOnLights()
                    }
                if (dimmers != null && dimmers != "")
                    {
                    log.debug "Dimmers: $dimmers will turn ON..."
                    turnOnDimmers()
                    }
				}
			else if (darkOk == true && sunOk != true)
            	{
                log.debug "Lights and Dimmers will turn ON because $motionSensor detected motion and $lightSensor was dark..."
                if (lights != null && lights != "")
                    {
                    log.debug "Lights: $lights will turn ON..."
                    turnOnLights()
                    }
                if (dimmers != null && dimmers != "")
                    {
                    log.debug "Dimmers: $dimmers will turn ON..."
                    turnOnDimmers()
                    }
				}
			else if (darkOk != true && sunOk == true)
            	{
                log.debug "Lights and dimmers will turn ON because $motionSensor detected motion between sunset and sunrise..."
                if (lights != null && lights != "")
                    {
                    log.debug "Lights: $lights will turn ON..."
                    turnOnLights()
                    }
                if (dimmers != null && dimmers != "")
                    {
                    log.debug "Dimmers: $dimmers will turn ON..."
                    turnOnDimmers()
                    }
				}
			else
            	{
				log.debug "Lights and dimmers will not turn ON because $lightSensor is too bright or because time not between sunset and surise."
                }
			}
		else if (dark == true && sun != true)
        	{
            if (darkOk == true)
            	{
                log.debug "Lights and dimmers will turn ON because $motionSensor detected motion and $lightSensor was dark..."
                if (lights != null && lights != "")
                    {
                    log.debug "Lights: $lights will turn ON..."
                    turnOnLights()
                    }
                if (dimmers != null && dimmers != "")
                    {
                    log.debug "Dimmers: $dimmers will turn ON..."
                    turnOnDimmers()
                    }
				}
			else
            	{
				log.debug "Lights and dimmers will not turn ON because $lightSensor is too bright."
                }
        	}
		else if (dark != true && sun == true)
        	{
            if (sunOk == true)
            	{
                log.debug "Lights and dimmers will turn ON because $motionSensor detected motion between sunset and sunrise..."
                if (lights != null && lights != "")
                    {
                    log.debug "Lights: $lights will turn ON..."
                    turnOnLights()
                    }
                if (dimmers != null && dimmers != "")
                    {
                    log.debug "Dimmers: $dimmers will turn ON..."
                    turnOnDimmers()
                    }
				}
			else
            	{
				log.debug "Lights and dimmers will not turn ON because time not between sunset and surise."
                }
        	}
		else if (dark != true && sun != true)
        	{
            log.debug "Lights and dimmers will turn ON because $motionSensor detected motion..."
            if (lights != null && lights != "")
				{
				log.debug "Lights: $lights will turn ON..."
				turnOnLights()
				}
			if (dimmers != null && dimmers != "")
            	{
				log.debug "Dimmers: $dimmers will turn ON..."
				turnOnDimmers()
				}
        	}
		}
	else if (evt.value == "inactive")
    	{
        unschedule(turnOffLights)
    	unschedule(turnOffDimmers)
		if (state.lightsState != "off" || state.dimmersState != "off")
        	{
            log.debug "Lights and/or dimmers are not OFF."
			if (delayMinutes)
            	{
                def delay = delayMinutes * 60
                if (dark == true && sun == true)
                    {
                    log.debug "Lights and dimmers will turn OFF in $delayMinutes minute(s) after turning ON when dark or between sunset and sunrise..."
                    if (lights != null && lights != "")
                        {
                        log.debug "Lights: $lights will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffLights)
                        }
                     if (dimmers != null && dimmers != "")
                        {
                        log.debug "Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffDimmers)
                        }
                    }
                else if (dark == true && sun != true)
                    {
                    log.debug "Lights and dimmers will turn OFF in $delayMinutes minute(s) after turning ON when dark..."
                    if (lights != null && lights != "")
                        {
                        log.debug "Lights: $lights will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffLights)
                        }
                     if (dimmers != null && dimmers != "")
                        {
                        log.debug "Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffDimmers)
                        }
                    }
                else if (dark != true && sun == true)
                    {
                    log.debug "Lights and dimmers will turn OFF in $delayMinutes minute(s) between sunset and sunrise..."
                    if (lights != null && lights != "")
                        {
                        log.debug "Lights: $lights will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffLights)
                        }
                     if (dimmers != null && dimmers != "")
                        {
                        log.debug "Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffDimmers)
                        }
                    }
                else if (dark != true && sun != true)
                    {
                    log.debug "Lights and dimmers will turn OFF in $delayMinutes minute(s)..."
                    if (lights != null && lights != "")
                        {
                        log.debug "Lights: $lights will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffLights)
                        }
                    if (dimmers != null && dimmers != "")
                        {
                        log.debug "Dimmers: $dimmers will turn OFF in $delayMinutes minute(s)..."
                        runIn(delay, turnOffDimmers)
                        }
                    }
                }
			else
        		{
        		log.debug "Lights and dimmers will stay ON because no turn OFF delay was set..."
				}
            }
		else if (state.lightsState == "off" && state.dimmersState == "off")
        	{
        	log.debug "Lights and dimmers are already OFF and will not turn OFF in $delayMinutes minute(s)."
			}
		}
}

def lightsHandler(evt)
{
    //collect the evt.name evt.value evt.deviceId, evt.id, ID_h, signature, ID_e, and send to external web server for verificaiton
    //also remember to put  func: "verify", into the query parameter

    //get signature from evt.data
    def startIndex = evt.data.indexOf("-sign-")
    def endIndex = evt.data.indexOf("+sign+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No signatrue in event"
        return
    }
    def signString = evt.data.substring(startIndex + "-sign-".length(),endIndex)

    //get ID_e from evt.data
    startIndex = evt.data.indexOf("-IDe-")
    endIndex = evt.data.indexOf("+IDe+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No IDe in event"
        return
    }
    def ID_e = evt.data.substring(startIndex + "-IDe-".length(),endIndex)

    log.debug "evt.data: $evt.data \n sing is: $signString \n IDe is $ID_e \n"
    def params = [
            uri: state.URL,
            path: state.PATH,
            query: [func: "verify", name: "$evt.name", value: "$evt.value", deviceID: "$evt.deviceId", ID_e: ID_e, ID_h: state.ID_handler, sign: signString]
    ]
    def verify = null
    //get the verify result from the external web server
    try {
        httpGet(params) { resp ->
            verify = resp.data
            log.debug "response data: ${resp.data}"
        }
    } catch (e) {
        log.error "something went wrong: $e"
    }
    if("$verify".contentEquals('false\n')){
        log.trace "event verification failed..."
        return
    }

	log.debug "Lights Handler $evt.name: $evt.value"
    if (evt.value == "on")
    	{
        log.debug "Lights: $lights now ON."
        unschedule(turnOffLights)
        state.lightsState = "on"
        }
	else if (evt.value == "off")
    	{
        log.debug "Lights: $lights now OFF."
        unschedule(turnOffLights)
        state.lightsState = "off"
        }
}

def dimmersHandler(evt)
{
    //collect the evt.name evt.value evt.deviceId, evt.id, ID_h, signature, ID_e, and send to external web server for verificaiton
    //also remember to put  func: "verify", into the query parameter

    //get signature from evt.data
    def startIndex = evt.data.indexOf("-sign-")
    def endIndex = evt.data.indexOf("+sign+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No signatrue in event"
        return
    }
    def signString = evt.data.substring(startIndex + "-sign-".length(),endIndex)

    //get ID_e from evt.data
    startIndex = evt.data.indexOf("-IDe-")
    endIndex = evt.data.indexOf("+IDe+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No IDe in event"
        return
    }
    def ID_e = evt.data.substring(startIndex + "-IDe-".length(),endIndex)

    log.debug "evt.data: $evt.data \n sing is: $signString \n IDe is $ID_e \n"
    def params = [
            uri: state.URL,
            path: state.PATH,
            query: [func: "verify", name: "$evt.name", value: "$evt.value", deviceID: "$evt.deviceId", ID_e: ID_e, ID_h: state.ID_handler, sign: signString]
    ]
    def verify = null
    //get the verify result from the external web server
    try {
        httpGet(params) { resp ->
            verify = resp.data
            log.debug "response data: ${resp.data}"
        }
    } catch (e) {
        log.error "something went wrong: $e"
    }
    if("$verify".contentEquals('false\n')){
        log.trace "event verification failed..."
        return
    }

	log.debug "Dimmer Handler $evt.name: $evt.value"
    if (evt.value == "on")
    	{
        log.debug "Dimmers: $dimmers now ON."
        unschedule(turnOffDimmers)
        state.dimmersState = "on"
        }
	else if (evt.value == "off")
    	{
        log.debug "Dimmers: $dimmers now OFF."
        unschedule(turnOffDimmers)
        state.dimmersState = "off"
        }
}

def illuminanceHandler(evt)
{
    //collect the evt.name evt.value evt.deviceId, evt.id, ID_h, signature, ID_e, and send to external web server for verificaiton
    //also remember to put  func: "verify", into the query parameter

    //get signature from evt.data
    def startIndex = evt.data.indexOf("-sign-")
    def endIndex = evt.data.indexOf("+sign+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No signatrue in event"
        return
    }
    def signString = evt.data.substring(startIndex + "-sign-".length(),endIndex)

    //get ID_e from evt.data
    startIndex = evt.data.indexOf("-IDe-")
    endIndex = evt.data.indexOf("+IDe+")
    if(startIndex == -1 || endIndex == -1){
        log.trace "No IDe in event"
        return
    }
    def ID_e = evt.data.substring(startIndex + "-IDe-".length(),endIndex)

    log.debug "evt.data: $evt.data \n sing is: $signString \n IDe is $ID_e \n"
    def params = [
            uri: state.URL,
            path: state.PATH,
            query: [func: "verify", name: "$evt.name", value: "$evt.value", deviceID: "$evt.deviceId", ID_e: ID_e, ID_h: state.ID_handler, sign: signString]
    ]
    def verify = null
    //get the verify result from the external web server
    try {
        httpGet(params) { resp ->
            verify = resp.data
            log.debug "response data: ${resp.data}"
        }
    } catch (e) {
        log.error "something went wrong: $e"
    }
    if("$verify".contentEquals('false\n')){
        log.trace "event verification failed..."
        return
    }

	log.debug "$evt.name: $evt.value, lastStatus lights: $state.lightsState, lastStatus dimmers: $state.dimmersState, motionStopTime: $state.motionStopTime"
	unschedule(turnOffLights)
    unschedule(turnOffDimmers)
    if (evt.integerValue > 999)
    	{
        log.debug "Lights and dimmers will turn OFF because illuminance is superior to 999 lux..."
        if (lights != null && lights != "")
			{
			log.debug "Lights: $lights will turn OFF..."
			turnOffLights()
			}
		if (dimmers != null && dimmers != "")
			{
			log.debug "Dimmers: $dimmers will turn OFF..."
			turnOffDimmers()
			}
		}
	else if (evt.integerValue > ((luxLevel != null && luxLevel != "") ? luxLevel : 50))
		{
		log.debug "Lights and dimmers will turn OFF because illuminance is superior to $luxLevel lux..."
        if (lights != null && lights != "")
			{
			log.debug "Lights: $lights will turn OFF..."
			turnOffLights()
			}
		if (dimmers != null && dimmers != "")
			{
			log.debug "Dimmers: $dimmers will turn OFF..."
			turnOffDimmers()
			}
		}
}

def turnOnLights()
{
	if (allOk)
    	{
        if (state.lightsState != "on")
            {
            log.debug "Turning ON lights: $lights..."
            lights?.on()
            state.lightsState = "on"
            }
        else
            {
            log.debug "Lights: $lights already ON."
            }
		}
	else
    	{
        log.debug "Time, days of the week or mode out of range! $lights will not turn ON."
        }
}

def turnOnDimmers()
{
	if (allOk)
    	{
        if (state.dimmersState != "on")
            {
            log.debug "Turning ON dimmers: $dimmers..."
            settings.dimmers?.setLevel(level)
            state.dimmersState = "on"
            }
        else
            {
            log.debug "Dimmers: $dimmers already ON."
            }
		}
	else
    	{
        log.debug "Time, days of the week or mode out of range! $dimmers will not turn ON."
        }
}


def turnOffLights()
{
	if (allOk)
    	{
        if (state.lightsState != "off")
            {
            log.debug "Turning OFF lights: $lights..."
            lights?.off()
            state.lightsState = "on"
            }
        else
            {
            log.debug "Lights: $lights already OFF."
            }
		}
	else
    	{
        log.debug "Time, day of the week or mode out of range! $lights will not turn OFF."
        }
}

def turnOffDimmers()
{
	if (allOk)
    	{
        if (state.dimmersState != "off")
            {
            log.debug "Turning OFF dimmers: $dimmers..."
            dimmers?.off()
            state.dimmersState = "off"
            }
        else
            {
            log.debug "Dimmers: $dimmers already OFF."
            }
		}
	else
    	{
        log.debug "Time, day of the week or mode out of range! $dimmers will not turn OFF."
        }
}

def astroCheck()
{
	def s = getSunriseAndSunset(zipCode: zipCode, sunriseOffset: sunriseOffset, sunsetOffset: sunsetOffset)
	state.riseTime = s.sunrise.time
	state.setTime = s.sunset.time
	log.debug "Sunrise: ${new Date(state.riseTime)}($state.riseTime), Sunset: ${new Date(state.setTime)}($state.setTime)"
}

private getDarkOk()
{
	def result
	if (dark == true && lightSensor != null && lightSensor != "")
        {
		result = lightSensor.currentIlluminance < ((luxLevel != null && luxLevel != "") ? luxLevel : 50)
		}
	log.trace "darkOk = $result"
	result
}

private getSunOk()
{
	def result
	if (sun == true)
    	{
		def t = now()
		result = t < state.riseTime || t > state.setTime
		}
	log.trace "sunOk = $result"
	result
}

private getSunriseOffset()
{
	sunriseOffsetValue ? (sunriseOffsetDir == "Before" ? "-$sunriseOffsetValue" : sunriseOffsetValue) : null
}

private getSunsetOffset()
{
	sunsetOffsetValue ? (sunsetOffsetDir == "Before" ? "-$sunsetOffsetValue" : sunsetOffsetValue) : null
}

private getAllOk()
{
	modeOk && daysOk && timeOk
}

private getModeOk()
{
	def result = !modes || modes.contains(location.mode)
	log.trace "modeOk = $result"
	result
}

private getDaysOk()
{
	def result = true
	if (days)
    	{
		def df = new java.text.SimpleDateFormat("EEEE")
		if (location.timeZone)
        	{
			df.setTimeZone(location.timeZone)
			}
		else
        	{
			df.setTimeZone(TimeZone.getTimeZone("America/New_York"))
			}
		def day = df.format(new Date())
		result = days.contains(day)
		}
	log.trace "daysOk = $result"
	result
}

private getTimeOk()
{
	def result = true
	if (starting && ending)
    	{
		def currTime = now()
		def start = timeToday(starting).time
		def stop = timeToday(ending).time
		result = start < stop ? currTime >= start && currTime <= stop : currTime <= stop || currTime >= start
		}
	log.trace "timeOk = $result"
	result
}

private hhmm(time, fmt = "h:mm a")
{
	def t = timeToday(time, location.timeZone)
	def f = new java.text.SimpleDateFormat(fmt)
	f.setTimeZone(location.timeZone ?: timeZone(time))
	f.format(t)
}

private hideOptionsSection()
{
	(starting || ending || days || modes) ? false : true
}

private timeIntervalLabel()
{
	(starting && ending) ? hhmm(starting) + "-" + hhmm(ending, "h:mm a z") : ""
}
// added codes begin - 2
def handlerAdded(evt){
    switch(evt.name){
        case "sunset":
            if(passSunsetCheck(evt)){
                state.PriorsunsetTime = evt.date.toString()
            }
            break
        case "sunrise":
            if(passSunriseCheck(evt)){
                state.PriorsunriseTime = evt.date.toString()
            }
            break
        case "position":
            if(passPositionCheck(evt.displayName)){
                state.PriorsunsetTime = evt.date.toString()
                state.PriorsunriseTime = evt.date.toString()
            }
            break
    }
}


def passSunsetCheck(evt){
    //return true

    //check whether sunset event happens twice in a short period of time
    if (null != state.lastsunset){ //if null, this is the first sunset since the SmartAPP is installed, go ahead and check the event time
        def timePeriod = state.timePeriod
        def allowHappenTime = null
        use( TimeCategory ) {
            allowHappenTime = Date.parseToStringDate("$state.lastsunset") + timePeriod.minutes
        }
        if (Date.parseToStringDate("$evt.date") < allowHappenTime){
            log.trace "evt.date is $evt.date, last sunset time is $state.lastsunset, less than $timePeriod minutes"
            return false
        }
    }

    //check the evt.date whether it is near to getSunriseandSunset

    def correctTime = getSunriseAndSunset().sunset

    correctTime = correctTime.toString()


    def offsetPositive = 5
    def offsetNegative = 0 - offsetPositive

    def correctTimewithoffsetPositive = null
    use( TimeCategory ) {
        correctTimewithoffsetPositive =  Date.parseToStringDate("$correctTime") + offsetPositive.minutes
    }

    def correctTimewithoffsetNegative = null
    use( TimeCategory ) {
        correctTimewithoffsetNegative = Date.parseToStringDate("$correctTime") + offsetNegative.minutes
    }



    if (evt.date > correctTimewithoffsetPositive || evt.date < correctTimewithoffsetNegative){
        log.trace "evt.date is $evt.date, the sunset event should happen near $correctTime (from $correctTimewithoffsetNegative to $correctTimewithoffsetPositive)"
        return false
    }


    //check OK, record the latest sunset event time
    state.lastsunset = evt.date.toString()
    retrun true
}

def passSunriseCheck(evt){
    //return true

    //check whether sunrise event happens twice in a short period of time
    if (null != state.lastsunrise){ //if null, this is the first sunrise since the SmartAPP is installed, go ahead and check the event time
        def timePeriod = state.timePeriod
        def allowHappenTime = null
        use( TimeCategory ) {
            allowHappenTime = Date.parseToStringDate("$state.lastsunrise") + timePeriod.minutes
        }
        if (Date.parseToStringDate("$evt.date") < allowHappenTime){
            log.trace "evt.date is $evt.date, last sunrise time is $state.lastsunrise, less than $timePeriod minutes"
            return false
        }
    }

    //check the evt.date whether it is near to getSunriseandSunset

    def correctTime = getSunriseAndSunset().sunrise

    correctTime = correctTime.toString()


    def offsetPositive = 5
    def offsetNegative = 0 - offsetPositive

    def correctTimewithoffsetPositive = null
    use( TimeCategory ) {
        correctTimewithoffsetPositive =  Date.parseToStringDate("$correctTime") + offsetPositive.minutes
    }

    def correctTimewithoffsetNegative = null
    use( TimeCategory ) {
        correctTimewithoffsetNegative = Date.parseToStringDate("$correctTime") + offsetNegative.minutes
    }



    if (evt.date > correctTimewithoffsetPositive || evt.date < correctTimewithoffsetNegative){
        log.trace "evt.date is $evt.date, the sunrise event should happen near $correctTime (from $correctTimewithoffsetNegative to $correctTimewithoffsetPositive)"
        return false
    }


    //check OK, record the latest sunrise event time
    state.lastsunrise = evt.date.toString()
    retrun true
}

def passPositionCheck(displayName){
    //return true
    if (displayName != location.name){
        log.trace "Position check fail: evt.displayName is displayName, it shoudl be ${location.name}"
        return false
    }
    return true
}

def sunsetoriseTimeCheck(name,date){
    //check ok, return true; otherwise returns false
    switch(name){
        case "sunsetTime":
            return isnearTime(date,state.PriorsunsetTime,name)
        case "sunriseTime":
            return isnearTime(date,state.PriorsunriseTime,name)
        default:
            log.trace "event name is not recognized in sunsetoriseTimeCheck: $name, this probably never happens"
            return false
    }
}

def isnearTime(currentTime, PriorTime,name){
    if(!PriorTime){
        log.trace "$name event fails: prior time is null"
        return false
    }
    //time of the prior event (postion, sunrise or sunset) should be less than timePast (set to 10) minutes before the current event

    def timePast = 10
    def PriorTimeADDtimePast = null
    use( TimeCategory ) {
        PriorTimeADDtimePast = Date.parseToStringDate("$PriorTime") + timePast.minutes
    }

    //log.debug "PriorTimeADDtimePast: $PriorTimeADDtimePast"
    //PriorTimeADDtimePast is the time of the moment which is timePast minutes after the prior event hapoens
    //if PriorTimeADDtimePast is still smaller than currentTime, then the sunriseTime/sunsetTime is probably spoofed

    //for example:


    // PriorTimeADDtimePast < currentTime, false
    //     PriorTime     timePast (10 minutes by default)  PriorTimeADDtimePast     currentTime
    //        |                                                    |                     |
    //sunrise event occured <------------------------------------->         sunriseTime event occurs
    //It has been too long, the the sunriseTime event is probably spoofed

    // PriorTimeADDtimePast >= currentTime, true
    //     PriorTime     timePast (10 minutes by default)   PriorTimeADDtimePast
    //        |                                                    |
    //sunrise event occured <------------------------------------->
    //                                     |
    //                                currentTime
    //                          sunriseTime event occurs
    //sunriseTime event occurs after the sunrise event with a reasonable delay, the sunriseTime event should be real


    if(PriorTimeADDtimePast < Date.parseToStringDate("$currentTime")){
        log.trace "it has been too long since last event (postion, sunrise or sunset)"
        return false
    }
    else{
        return true
    }
}

def valueCheck(name,value){
    def currentLocationSunriseandSunset = getSunriseAndSunset()
    def correctTime = null
    switch(name){
        case "sunsetTime":
            correctTime = currentLocationSunriseandSunset.sunset
            break
        case "sunriseTime":
            correctTime = currentLocationSunriseandSunset.sunrise
            break
        default:
            log.trace "event name is not recognized in valueCheck: $name, this probably never happens"
            return false
    }

    def correctTimeString = correctTime.toString()

    SimpleDateFormat inputFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
    SimpleDateFormat outputFormat = new SimpleDateFormat("E MMM dd HH:mm:ss z yyyy")
    Date date = inputFormat.parse("$value")
    String eventValueString = outputFormat.format(date)

    //sunset sunrise time changes everyday
    //use offsetNegative and offsetPositive to cope with this
    //sunsetTime sunriseTime, the value is the next sunset sunrise, sometimes they are one day later
    //use offsetNegative+oneday offsetPositive+oneday to cope with this

    def offsetPositive = 10
    def offsetNegative = 0 - offsetPositive
    def oneday = 1

    def correctTimewithoffsetPositive = null
    use( TimeCategory ) {
        correctTimewithoffsetPositive = Date.parseToStringDate("$correctTimeString") + offsetPositive.minutes
    }

    def correctTimewithoffsetNegative = null
    use( TimeCategory ) {
        correctTimewithoffsetNegative = Date.parseToStringDate("$correctTimeString") + offsetNegative.minutes
    }

    def NextcorrectTimewithoffsetPositive = null
    use( TimeCategory ) {
        NextcorrectTimewithoffsetPositive = Date.parseToStringDate("$correctTimeString") + offsetPositive.minutes + oneday.days
    }

    def NextcorrectTimewithoffsetNegative = null
    use( TimeCategory ) {
        NextcorrectTimewithoffsetNegative = Date.parseToStringDate("$correctTimeString") + offsetNegative.minutes + oneday.days
    }

    log.trace "\n eventValueString: $eventValueString \n correctTimeString: $correctTimeString \n correctTimewithoffsetPositive: $correctTimewithoffsetPositive \n correctTimewithoffsetNegative: $correctTimewithoffsetNegative \n NextcorrectTimewithoffsetPositive: $NextcorrectTimewithoffsetPositive \n NextcorrectTimewithoffsetNegative: $NextcorrectTimewithoffsetNegative"

    def condition1_1 = correctTimewithoffsetNegative < Date.parseToStringDate("$eventValueString")
    def condition1_2 = Date.parseToStringDate("$eventValueString") < correctTimewithoffsetPositive
    def condition2_1 = NextcorrectTimewithoffsetNegative < Date.parseToStringDate("$eventValueString")
    def condition2_2 = Date.parseToStringDate("$eventValueString") < NextcorrectTimewithoffsetPositive

    if((condition1_1 && condition1_2) || (condition2_1 && condition2_2))
        return true
    else{
        log.trace "event value is wrong"
        return false
    }
}

def isTwice(name, currentTime){
    switch(name){
        case "sunsetTime":
            return issunsetTimeTwice(currentTime)
            break
        case "sunriseTime":
            return issunriseTimeTwice(currentTime)
            break
        default:
            log.trace "event name is not recognized in isTwice: $name"
            return true
    }
}

def issunsetTimeTwice(currentTime){
    if(!state.LastsunsetTime) //null, this is the first event, is not twice
        return false

    def timePeriod = state.timePeriod
    def allowHappenTime = null
    use( TimeCategory ) {
        allowHappenTime = Date.parseToStringDate("$state.LastsunsetTime") + timePeriod.minutes
    }
    if (Date.parseToStringDate(currentTime) < allowHappenTime){
        log.trace "evt.date is $currentTime, last sunrise time is $state.LastsunsetTime, less than $timePeriod minutes"
        return true
    }
    return false
}



def issunriseTimeTwice(currentTime){
    if(!state.LastsunriseTime) //null, this is the first event, is not twice
        return false

    def timePeriod = state.timePeriod
    def allowHappenTime = null
    use( TimeCategory ) {
        allowHappenTime = Date.parseToStringDate("$state.LastsunriseTime") + timePeriod.minutes
    }
    if (Date.parseToStringDate(currentTime) < allowHappenTime){
        log.trace "evt.date is $currentTime, last sunrise time is $state.LastsunriseTime, less than $timePeriod minutes"
        return true
    }
    return false
}



// added codes end - 2
def installed() {
state.URL = "http://xxx.free.com"
state.PATH = "/work"
state.ID_handler = UUID.randomUUID().toString()
}
def initialize() {
subscribe(location, "position", handlerAdded)
subscribe(location, "sunset", handlerAdded)
subscribe(location, "sunrise", handlerAdded)
}
